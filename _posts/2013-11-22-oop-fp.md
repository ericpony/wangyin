---
layout: default
title: What's wrong with OOP and FP
---


I don't understand why there are endless debates about Object-Oriented Programming (OOP) and Functional Programming (FP). It seems that this type of thing is at the limit s of human intelligence, so you can argue about them for centuries. Over the years of doing programming languages research, I have seen the answer clearly, so I often find it pointless debating with people on these issues.
In short, both OOP and FP are wrong when you go to the extreme. The extreme of OOP is the notion everything is an object (pure OO). The extreme of FP is purely functional language.

### What's wrong with OOP

OOP is wrong because of its definition of an "object", and its attempt of trying to fit everything into it. When that goes to the extreme, you arrive at the notion "everything is an object". But this notion is wrong, because there exists things that are not objects. Functions are not objects.

You may argue that in Python or Scala, functions are also objects. In Python, every object with the method `__call__` is a function. Likewise, in Scala, functions are just objects with a method named apply. But after some careful thought, you will see that this is confusing the fundamental with the derived. `__call__` and apply are themselves the "function objects" you are trying to define in the first place. Python and Scala just kidnapped the functions, jailed them into "objects", labeled them `__call__` and `apply`, and then call them "methods". Of course, when you wrap a function into a object, you can use the object like a function, but this doesn't mean you can say "functions are also objects".

Most OO languages also lack correct implementations of first-class functions. An extreme is Java, which doesn't allow functions to be passed as data at all. You can always wrap functions into objects and call them "methods", but as I said, that's kidnapping. The lack of first-class functions is the major reason why there are so many "design patterns" in Java. Once you have first-class functions, you will need almost none of the design patterns.

### What's wrong with FP

Similarly, FP is wrong when you get to its extreme, a purely functional language. To discuss the topic, it is better to first have a good understanding what is a purely functional language. For this, you may want to read [What is a Purely Functional Language](http://people.csse.uwa.edu.au/~arran/key_papers/Sabry%20-%201998%20-%20What%20is%20a%20purely%20functional%20language.pdf) by Amr Sabry (who was my PhD adviser). But in short, a purely functional language is wrong because there exists things that are not pure. Side-effects are very real.

Being purely functional is basically ignoring the capabilities provided by the physical substrate (silicon chips, quantum chips or whatever). Instead, purely functional languages try to re-implement the universe in functions by passing the universe in and out. But there is a difference between the physical and the simulated. "side-effects" are physical. They truly exist in nature and are indispensable for computation to be efficient. Simulating them with pure functions is doomed to be inefficient, complicated and even ugly. Have you noticed how easy it is to implement circular data structures or random number generators in C? The same is not true for Haskell.

Also, purely functional languages cause a huge cognitive cost. If you look deep into them, monads make programs complicated and hard to write, and monad transformers are just ugly hacks. They are in the same spirit of "Java design patterns". Have you noticed how many easy things in other languages become research problems when you try to write them in Haskell? So you often see papers titled like "A Monadic Approach to a-solved-problem". Interestingly, Amr Sabry coauthored such a paper. The story was, he tried to re-implement Dan Friedman's miniKanren in Haskell, but couldn't figure out how to compose the monads. He had to seek help from Oleg kiselyov, arguably the world's most knowledgeable person about Haskell's type system. And if you don't know, Amr Sabry is probably the world's most knowledgeable person about purely functional programming languages. They coauthored a [paper](http://okmij.org/ftp/Computation/monads.html#LogicT) after solving the problem with Oleg's help. Ironically, Dan Friedman, the original author of that piece of code, didnâ€™t have any such trouble writing it in Scheme in the first place. Certainly there is no reason Amr should be able to figure out how to compose the monads. He and Oleg just wrote the Haskell code for fun, but this story tells me something about monads: they make things unnecessarily complicated.